****ALGORITHMS****

[RECURSION]
* function call inside same function.
* can be transformed into iteration. vice versa.
* each recursive call has its own stack frame isolated from each other.
* tail recursion: call function at the end. no stack overflow.
* head recursion: call function at the beginning. push previous states to stack then pop them from stack. stack overflow risk.
* taylor recursion: store previous states in accumulator then pass to next call. memory efficient.
* sum, factorial, fibonacci, binary search, towers of hanoi, ...

[LINEAR SEARCH]
* unsorted array. one by one. O(N) running time. N array elements.

[BINARY SEARCH]
* sorted array. O(logN) running time. tail recursion. N array elements.
* divide array in half. if smaller than middle take left-hand otherwise right-hand then repeat.

[TOWERS OF HANOI]
* O(2^N) running time. N number of disks.
* three rods. many disks. one disk at a time. uppermost disk can move. smaller on larger.

[BACKTRACKING]
* constraint satisfaction problems. combinatorial optimization problems. depth-first search.
* incrementally build possible canditates to solution. abandon invalid canditates and backtrack. solution tree.
* faster than brute-force which tests all possible solutions.
* exponential running time. too slow.
* n-queen's, vertex coloring, sudoku, knight's tour, np-complete, np-hard ...
* meta-heuristics: approximate solutions to np problems. ant-colony optimization, genetic algorithms, simulated annealing

[N-QUEEN's PROBLEM]
* placing N queens on an NxN chess board such that no queen threatens any other.

[VERTEX COLORING PROBLEM]
* np-complete problem.
* coloring vertices of a graph such that no two adjacent vertices share same color.
* chromatic number: smallest number of colors needed.
* there may be more than one solution.
* bipartite graph, making schedule, radio frequency assignment, register allocation, map coloring ...
* four-color theorem.
* power-welsh algorithm.

[KNIGHT's TOUR PROBLEM]
* knight visits every square on a chessboard exactly once. hamiltonian-path problem.
* closed knight's tour: knight's ending point is same as the starting point. hamiltonian-cycle problem.
* Schwenk Theorem: for an mxn chessboard the closed knight tour problem is always feasible, unless:
  - m and n are both odds
  - m = 1, 2 or 4
  - m = 3 and n = 4, 6 or 8

[DYNAMIC PROGRAMMING]
* dynamic programming: dividing complex problems into simpler sub-programs. overlapping sub-problems. O(N) linear time complexity.
* memoization: store previous calculations and fetch them if needed later. don't recalculate. O(1) time complexity.
* divide and conquer: combining optimal solutions to non-overlapping sub-problems. merge/quick sort.

[FIBONACCI NUMBERS]
F(N) = F(N-1) + F(N-2)
F(0) = 0, F(1) = 1

[KNAPSACK PROBLEM]
* combinatorial optimization. resource allocation.
* set of N items, each has mass w and value v. total mass in knapsack shouldn't exceed W. make total value V large as possible.
* divisible knapsack problem: if there are fractions of items then greedy approach.
  - sort items according to their values. O(N*logN) time complexity.
  - start with most valuable item and take as much as possible. then try with next item. O(N) time complexity.
  - overall complexity: O(N*logN) + O(N) = O(N*logN)
* 0-1 knapsack problem: no fractions.
* S[i][w]: maximum cost of items that fit inside a knapsack of size weight w, choosing from the first i items.
* S[i][w] = Math.max(S[i-1][w]; vi + S[i-1][w-wi])
  - weights columns: 0-W
  - items rows: 0-N
  - knapsack with weight capacity x, number of items y, each item has a value, obtain maximum possible value without exceeding x.
  - value in last row-column
* O(n*W) running time. pseudo-polynomial. running time; polynomial in numeric value, exponential in the length of the input.
